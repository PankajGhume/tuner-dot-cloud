!function(n){function e(i){if(t[i])return t[i].exports;var a=t[i]={exports:{},id:i,loaded:!1};return n[i].call(a.exports,a,a.exports,e),a.loaded=!0,a.exports}var t={};return e.m=n,e.c=t,e.p="",e(0)}([function(module,exports,__webpack_require__){eval("'use strict';\n\nvar _pitchfinder = __webpack_require__(1);\n\nvar _pitchfinder2 = _interopRequireDefault(_pitchfinder);\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nlet detector = null; /* eslint-env worker */\n/* global PitchFinder */\n// import FFT from 'exports?FFT!./pitchfinder-js/fft.js';\n\n\nself.addEventListener('message', function (evt) {\n  switch (evt.data.type) {\n    case 'init':\n      delete evt.data.type;\n      detector = _pitchfinder2.default.YIN(evt.data);\n      return;\n\n    case 'detect':\n      var _detector = detector(new Float32Array(evt.data.channelData));\n\n      const freq = _detector.freq;\n\n      postMessage({\n        pitch: freq\n      });\n  }\n});\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/babel-loader!./~/eslint-loader!./src/pitchfinder-worker.js\n ** module id = 0\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/pitchfinder-worker.js?./~/babel-loader!./~/eslint-loader")},function(module,exports){eval('"use strict";\n\n/* An Javascript port of Tarsos\'s JAVA implementation\n * of various pitch detection algorithms, created by\n * Joren Six of University College Ghent.\n *\n * Contains the following algorithms:\n * YIN (with and without FFT; the version with requires an external FFT library)\n * Average Magnitude Difference\n * Dynamic Wavelet\n * McLeod Pitch Method\n *\n * Since this Javascript and we have first-class functions,\n * each method creates and returns a pitch detector function\n * with the given configuration.  When called with a float32Array\n * representing an audio buffer, it returns the pitch.\n *\n * Methods vary in accuracy and speed.  I have found the best results with YIN.\n *\n * Find the original project at http://tarsos.0110.be/tag/TarsosDSP\n * or on Github at https://github.com/JorenSix/TarsosDSP\n */\n\nvar PitchFinder = {};\n\n(function (pf) {\n  pf.AMDF = function (config) {\n    config = config || {};\n\n    var AMDF = {};\n\n    var DEFAULT_MIN_FREQUENCY = 82,\n        DEFAULT_MAX_FREQUENCY = 1000,\n        DEFAULT_RATIO = 5,\n        DEFAULT_SENSITIVITY = 0.1,\n        DEFAULT_SAMPLE_RATE = 44100,\n        sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE,\n        minFrequency = config.minFrequency || DEFAULT_MIN_FREQUENCY,\n        maxFrequency = config.maxFrequency || DEFAULT_MAX_FREQUENCY,\n        sensitivity = config.sensitivity || DEFAULT_SENSITIVITY,\n        ratio = config.ratio || DEFAULT_RATIO,\n        amd = [],\n        maxPeriod = Math.round(sampleRate / minFrequency + 0.5),\n        minPeriod = Math.round(sampleRate / maxFrequency + 0.5),\n        result = {};\n\n    return function (float32AudioBuffer) {\n      var t,\n          minval = Infinity,\n          maxval = -Infinity,\n          frames1,\n          frames2,\n          calcSub,\n          maxShift = float32AudioBuffer.length;\n\n      // Find the average magnitude difference for each possible period offset.\n      for (var i = 0; i < maxShift; i++) {\n        if (minPeriod <= i && i <= maxPeriod) {\n          t = 0;\n          frames1 = []; // The magnitudes from the start of the buffer.\n          frames2 = []; // The magnitudes from the start of the buffer plus the offset.\n          for (var aux1 = 0, aux2 = i, t = 0; aux1 < maxShift - i; t++, aux2++, aux1++) {\n            frames1[t] = float32AudioBuffer[aux1];\n            frames2[t] = float32AudioBuffer[aux2];\n          }\n\n          // Take the difference between these frames.\n          var frameLength = frames1.length;\n          calcSub = [];\n          for (var u = 0; u < frameLength; u++) {\n            calcSub[u] = frames1[u] - frames2[u];\n          }\n\n          // Sum the differences.\n          var summation = 0;\n          for (var l = 0; l < frameLength; l++) {\n            summation += Math.abs(calcSub[l]);\n          }\n          amd[i] = summation;\n        }\n      }\n\n      for (var j = minPeriod; j < maxPeriod; j++) {\n        if (amd[j] < minval) minval = amd[j];\n        if (amd[j] > maxval) maxval = amd[j];\n      }\n\n      var cutoff = Math.round(sensitivity * (maxval - minval) + minval);\n      for (j = minPeriod; j <= maxPeriod && amd[j] > cutoff; j++);\n\n      var search_length = minPeriod / 2;\n      minval = amd[j];\n      var minpos = j;\n      for (i = j - 1; i < j + search_length && i <= maxPeriod; i++) {\n        if (amd[i] < minval) {\n          minval = amd[i];\n          minpos = i;\n        }\n      }\n\n      if (Math.round(amd[minpos] * ratio) < maxval) {\n        return { freq: sampleRate / minpos };\n      } else {\n        return { freq: -1 };\n      }\n    };\n  };\n\n  // Constructor function for the YIN pitch detector, using the FFT optimization.\n  // NOTE: Make sure to include FFT.js\n  pf.FastYIN = function (config) {\n\n    config = config || {};\n\n    if (!window.FFT) throw "No FFT provided.";\n\n    var DEFAULT_THRESHOLD = 0.10,\n        DEFAULT_BUFFER_SIZE = 2048,\n        DEFAULT_SAMPLE_RATE = 44100,\n        threshold = config.threshold || DEFAULT_THRESHOLD,\n        sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE,\n        bufferSize = config.bufferSize || DEFAULT_BUFFER_SIZE,\n        yinBuffer = new Float32Array(bufferSize / 2),\n        yinBufferLength = bufferSize / 2,\n        audioBufferFFT = new Float32Array(2 * bufferSize),\n        kernel = new Float32Array(2 * bufferSize),\n        yinStyleACF = new Float32Array(2 * bufferSize),\n        FFT = window.FFT,\n        result = {};\n\n    // Implements the difference function using an FFT.\n    var difference = function (float32AudioBuffer) {\n      // Power term calculation.\n      var powerTerms = new Float32Array(bufferSize / 2);\n      // First term.\n      for (var j = 0; j < bufferSize / 2; j++) {\n        powerTerms[0] += float32AudioBuffer[j] * float32AudioBuffer[j];\n      }\n      // Iteratively calculate later terms.\n      for (var tau = 1; tau < bufferSize / 2; tau++) {\n        powerTerms[tau] = powerTerms[tau - 1] - float32AudioBuffer[tau - 1] * float32AudioBuffer[tau - 1] + float32AudioBuffer[tau + bufferSize / 2] * float32AudioBuffer[tau + bufferSize / 2];\n      }\n\n      // YIN-style autocorrelation via FFT\n      // 1. data\n      FFT.complex(audioBufferFFT, float32AudioBuffer, false);\n\n      // 2. half of the data, disguised as a convolution kernel\n      var halfData = new Float32Array(yinBufferLength);\n      for (var j = 0; j < yinBufferLength; j++) {\n        halfData[j] = float32AudioBuffer[yinBufferLength - 1 - j];\n      }\n      FFT.complex(kernel, halfData, false);\n\n      // 3. Convolution via complex multiplication\n    };\n\n    return function () {};\n  };\n\n  // Constructor function for the YIN pitch dectector.\n  pf.YIN = function (config) {\n\n    config = config || {};\n\n    var YIN = {};\n\n    var DEFAULT_THRESHOLD = 0.10,\n        DEFAULT_BUFFER_SIZE = 2048,\n        DEFAULT_SAMPLE_RATE = 44100,\n        threshold = config.threshold || DEFAULT_THRESHOLD,\n        sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE,\n        bufferSize = config.bufferSize || DEFAULT_BUFFER_SIZE,\n        yinBuffer = new Float32Array(bufferSize / 2),\n        yinBufferLength = bufferSize / 2,\n        result = {};\n\n    // Implements the difference function as described in step 2 of the YIN paper.\n    var difference = function (float32AudioBuffer) {\n      var index, delta;\n      for (var tau = 0; tau < yinBufferLength; tau++) {\n        yinBuffer[tau] = 0;\n      }\n      for (tau = 1; tau < yinBufferLength; tau++) {\n        for (index = 0; index < yinBufferLength; index++) {\n          delta = float32AudioBuffer[index] - float32AudioBuffer[index + tau];\n          yinBuffer[tau] += delta * delta;\n        }\n      }\n    };\n\n    // Implements the cumulative mean normalized difference as described in step 3 of the paper.\n    var cumulativeMeanNormalizedDifference = function () {\n      yinBuffer[0] = 1;\n      yinBuffer[1] = 1;\n      var runningSum = 0;\n      for (var tau = 1; tau < yinBufferLength; tau++) {\n        runningSum += yinBuffer[tau];\n        yinBuffer[tau] *= tau / runningSum;\n      }\n    };\n\n    var absoluteThreshold = function () {\n      // Since the first two positions in the array are 1,\n      // we can start at the third position.\n      for (var tau = 2; tau < yinBufferLength; tau++) {\n        if (yinBuffer[tau] < threshold) {\n          while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n            tau++;\n          }\n          // found tau, exit loop and return\n          // store the probability\n          // From the YIN paper: The threshold determines the list of\n          // candidates admitted to the set, and can be interpreted as the\n          // proportion of aperiodic power tolerated\n          // within a periodic signal.\n          //\n          // Since we want the periodicity and and not aperiodicity:\n          // periodicity = 1 - aperiodicity\n          result.probability = 1 - yinBuffer[tau];\n          break;\n        }\n      }\n\n      // if no pitch found, set tau to -1\n      if (tau == yinBufferLength || yinBuffer[tau] >= threshold) {\n        tau = -1;\n        result.probability = 0;\n        result.foundPitch = false;\n      } else {\n        result.foundPitch = true;\n      }\n\n      return tau;\n    };\n\n    /**\n     * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n     * value using parabolic interpolation. This is needed to detect higher\n     * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n     * for more background\n     * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n     */\n\n    var parabolicInterpolation = function (tauEstimate) {\n      var betterTau, x0, x2;\n\n      if (tauEstimate < 1) {\n        x0 = tauEstimate;\n      } else {\n        x0 = tauEstimate - 1;\n      }\n      if (tauEstimate + 1 < yinBufferLength) {\n        x2 = tauEstimate + 1;\n      } else {\n        x2 = tauEstimate;\n      }\n      if (x0 === tauEstimate) {\n        if (yinBuffer[tauEstimate] <= yinBuffer[x2]) {\n          betterTau = tauEstimate;\n        } else {\n          betterTau = x2;\n        }\n      } else if (x2 === tauEstimate) {\n        if (yinBuffer[tauEstimate] <= yinBuffer[x0]) {\n          betterTau = tauEstimate;\n        } else {\n          betterTau = x0;\n        }\n      } else {\n        var s0, s1, s2;\n        s0 = yinBuffer[x0];\n        s1 = yinBuffer[tauEstimate];\n        s2 = yinBuffer[x2];\n        // fixed AUBIO implementation, thanks to Karl Helgason:\n        // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n        betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n      }\n      return betterTau;\n    };\n\n    // Return the pitch of a given signal, or -1 if none is detected.\n    return function (float32AudioBuffer) {\n\n      // Step 2\n      difference(float32AudioBuffer);\n\n      // Step 3\n      cumulativeMeanNormalizedDifference();\n\n      // Step 4\n      var tauEstimate = absoluteThreshold();\n\n      // Step 5\n      if (tauEstimate !== -1) {\n\n        var betterTau = parabolicInterpolation(tauEstimate);\n\n        // TODO: optimization!\n\n        result.freq = sampleRate / betterTau;\n      } else {\n\n        result.freq = -1;\n      }\n\n      // Good luck!\n      return result;\n    };\n  };\n\n  // Construtor function for Dynamic Wavelet detector\n  pf.DW = function (config) {\n\n    config = config || {};\n\n    var maxFLWTlevels = 6,\n        maxF = 3000,\n        differenceLevelsN = 3,\n        maximaThresholdRatio = 0.75,\n        sampleRate = config.sampleRate || 44100,\n        bufferLength = config.bufferSize || 1024,\n        distances = [],\n        mins = [],\n        maxs = [],\n        result = {};\n\n    return function (float32AudioBuffer) {\n      var pitchF = -1,\n          curSamNb = float32AudioBuffer.length,\n          nbMins,\n          nbMaxs,\n          amplitudeThreshold,\n          theDC = 0,\n          minValue = 0,\n          maxValue = 0;\n\n      // Compute max amplitude, amplitude threshold, and the DC.\n      for (var i = 0; i < bufferLength; i++) {\n        var sample = float32AudioBuffer[i];\n        theDC = theDC + sample;\n        maxValue = Math.max(maxValue, sample);\n        minValue = Math.min(minValue, sample);\n      }\n\n      theDC = theDC / bufferLength;\n      minValue -= theDC;\n      maxValue -= theDC;\n      var amplitudeMax = maxValue > -1 * minValue ? maxValue : -1 * minValue;\n\n      amplitudeThreshold = amplitudeMax * maximaThresholdRatio;\n\n      // levels, start without downsampling...\n      var curLevel = 0,\n          curModeDistance = -1,\n          delta;\n\n      // Search:\n      while (true) {\n        delta = ~ ~(sampleRate / (Math.pow(2, curLevel) * maxF));\n        if (curSamNb < 2) break;\n\n        var dv,\n            previousDV = -1000,\n            lastMinIndex = -1000000,\n            lastMaxIndex = -1000000,\n            findMax = false,\n            findMin = false;\n\n        nbMins = 0;\n        nbMaxs = 0;\n\n        for (var i = 2; i < curSamNb; i++) {\n          var si = float32AudioBuffer[i] - theDC,\n              si1 = float32AudioBuffer[i - 1] - theDC;\n\n          if (si1 <= 0 && si > 0) findMax = true;\n          if (si1 >= 0 && si < 0) findMin = true;\n\n          // min or max ?\n          dv = si - si1;\n\n          if (previousDV > -1000) {\n            if (findMin && previousDV < 0 && dv >= 0) {\n              // minimum\n              if (Math.abs(si) >= amplitudeThreshold) {\n                if (i > lastMinIndex + delta) {\n                  mins[nbMins++] = i;\n                  lastMinIndex = i;\n                  findMin = false;\n                }\n              }\n            }\n\n            if (findMax && previousDV > 0 && dv <= 0) {\n              // maximum\n              if (Math.abs(si) >= amplitudeThreshold) {\n                if (i > lastMinIndex + delta) {\n                  maxs[nbMaxs++] = i;\n                  lastMaxIndex = i;\n                  findMax = false;\n                }\n              }\n            }\n          }\n          previousDV = dv;\n        }\n\n        if (nbMins === 0 && nbMaxs === 0) {\n          // No best distance found!\n          break;\n        }\n\n        var d,\n            distances = [];\n\n        for (var i = 0; i < nbMins; i++) {\n          for (var j = 1; j < differenceLevelsN; j++) {\n            if (i + j < nbMins) {\n              d = Math.abs(mins[i] - mins[i + j]);\n              distances[d] = distances[d] + 1;\n            }\n          }\n        }\n\n        var bestDistance = -1,\n            bestValue = -1;\n\n        for (var i = 0; i < curSamNb; i++) {\n          var summed = 0;\n          for (var j = -delta; j <= delta; j++) {\n            if (i + j >= 0 && i + j < curSamNb) {\n              summed += distances[i + j];\n            }\n          }\n\n          if (summed === bestValue) {\n            if (i === 2 * bestDistance) {\n              bestDistance = i;\n            }\n          } else if (summed > bestValue) {\n            bestValue = summed;\n            bestDistance = i;\n          }\n        }\n\n        // averaging\n        var distAvg = 0,\n            nbDists = 0;\n        for (var j = -delta; j <= delta; j++) {\n          if (bestDistance + j >= 0 && bestDistance + j < bufferLength) {\n            var nbDist = distances[bestDistance + j];\n            if (nbDist > 0) {\n              nbDists += nbDist;\n              distAvg += (bestDistance + j) * nbDist;\n            }\n          }\n        }\n\n        // This is our mode distance.\n        distAvg /= nbDists;\n\n        // Continue the levels?\n        if (curModeDistance > -1) {\n          var similarity = Math.abs(distAvg * 2 - curModeDistance);\n          if (similarity <= 2 * delta) {\n            // two consecutive similar mode distances : ok !\n            pitchF = sampleRate / (Math.pow(2, curLevel - 1) * curModeDistance);\n            break;\n          }\n        }\n\n        // not similar, continue next level;\n        curModeDistance = distAvg;\n\n        curLevel++;\n        if (curLevel >= maxFLWTlevels || curSamNb < 2) {\n          break;\n        }\n\n        //do not modify original audio buffer, make a copy buffer, if\n        //downsampling is needed (only once).\n        var newFloat32AudioBuffer = float32AudioBuffer.subarray(0);\n        if (curSamNb === distances.length) {\n          newFloat32AudioBuffer = new Float32Array(curSamNb / 2);\n        }\n        for (var i = 0; i < curSamNb / 2; i++) {\n          newFloat32AudioBuffer[i] = (float32AudioBuffer[2 * i] + float32AudioBuffer[2 * i + 1]) / 2;\n        }\n        float32AudioBuffer = newFloat32AudioBuffer;\n        curSamNb /= 2;\n      }\n\n      result.freq = pitchF;\n\n      return result;\n    };\n  };\n\n  // Constructor function for McLeod Pitch Method detector.\n  // Note: Quite slow..\n  pf.MPM = function (config) {\n\n    config = config || {};\n\n    /**\n     * The expected size of an audio buffer (in samples).\n     */\n    var DEFAULT_BUFFER_SIZE = 1024,\n\n\n    /**\n     * Defines the relative size the chosen peak (pitch) has. 0.93 means: choose\n     * the first peak that is higher than 93% of the highest peak detected. 93%\n     * is the default value used in the Tartini user interface.\n     */\n    DEFAULT_CUTOFF = 0.97,\n        DEFAULT_SAMPLE_RATE = 44100,\n\n\n    /**\n     * For performance reasons, peaks below this cutoff are not even considered.\n     */\n    SMALL_CUTOFF = 0.5,\n\n\n    /**\n     * Pitch annotations below this threshold are considered invalid, they are\n     * ignored.\n     */\n    LOWER_PITCH_CUTOFF = 88,\n\n\n    /**\n     * Defines the relative size the chosen peak (pitch) has.\n     */\n    cutoff = config.cutoff,\n\n\n    /**\n     * The audio sample rate. Most audio has a sample rate of 44.1kHz.\n     */\n    sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE,\n\n\n    /**\n     * Size of the input buffer.\n     */\n    bufferSize = config.bufferSize || DEFAULT_BUFFER_SIZE,\n\n\n    /**\n     * Contains a normalized square difference function value for each delay\n     * (tau).\n     */\n    nsdf = new Float32Array(bufferSize),\n\n\n    /**\n     * The x and y coordinate of the top of the curve (nsdf).\n     */\n    turningPointX,\n        turningPointY,\n\n\n    /**\n     * A list with minimum and maximum values of the nsdf curve.\n     */\n    maxPositions = [],\n\n\n    /**\n     * A list of estimates of the period of the signal (in samples).\n     */\n    periodEstimates = [],\n\n\n    /**\n     * A list of estimates of the amplitudes corresponding with the period\n     * estimates.\n     */\n    ampEstimates = [],\n\n\n    /**\n     * The result of the pitch detection iteration.\n     */\n    result = {};\n\n    /**\n     * Implements the normalized square difference function. See section 4 (and\n     * the explanation before) in the MPM article. This calculation can be\n     * optimized by using an FFT. The results should remain the same.\n     */\n    var normalizedSquareDifference = function (float32AudioBuffer) {\n      for (var tau = 0; tau < float32AudioBuffer.length; tau++) {\n        var acf = 0,\n            divisorM = 0;\n        for (var i = 0; i < float32AudioBuffer.length - tau; i++) {\n          acf += float32AudioBuffer[i] * float32AudioBuffer[i + tau];\n          divisorM += float32AudioBuffer[i] * float32AudioBuffer[i] + float32AudioBuffer[i + tau] * float32AudioBuffer[i + tau];\n        }\n        nsdf[tau] = 2 * acf / divisorM;\n      }\n    };\n\n    /**\n     * Finds the x value corresponding with the peak of a parabola.\n     * Interpolates between three consecutive points centered on tau.\n     */\n    var parabolicInterpolation = function (tau) {\n      var nsdfa = nsdf[tau - 1],\n          nsdfb = nsdf[tau],\n          nsdfc = nsdf[tau + 1],\n          bValue = tau,\n          bottom = nsdfc + nsdfa - 2 * nsdfb;\n      if (bottom === 0) {\n        turningPointX = bValue;\n        turningPointY = nsdfb;\n      } else {\n        var delta = nsdfa - nsdfc;\n        turningPointX = bValue + delta / (2 * bottom);\n        turningPointY = nsdfb - delta * delta / (8 * bottom);\n      }\n    };\n\n    // Finds the highest value between each pair of positive zero crossings.\n    var peakPicking = function () {\n      var pos = 0,\n          curMaxPos = 0;\n\n      // find the first negative zero crossing.\n      while (pos < nsdf.length - 1 / 3 && nsdf[pos] > 0) {\n        pos++;\n      }\n\n      // loop over all the values below zero.\n      while (pos < nsdf.length - 1 && nsdf[pos <= 0]) {\n        pos++;\n      }\n\n      // can happen if output[0] is NAN\n      if (pos == 0) {\n        pos = 1;\n      }\n\n      while (pos < nsdf.length - 1) {\n        if (nsdf[pos] > nsdf[pos - 1] && nsdf[pos] >= nsdf[pos + 1]) {\n          if (curMaxPos == 0) {\n            // the first max (between zero crossings)\n            curMaxPos = pos;\n          } else if (nsdf[pos] > nsdf[curMaxPos]) {\n            // a higher max (between the zero crossings)\n            curMaxPos = pos;\n          }\n        }\n        pos++;\n        // a negative zero crossing\n        if (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n          // if there was a maximum add it to the list of maxima\n          if (curMaxPos > 0) {\n            maxPositions.push(curMaxPos);\n            curMaxPos = 0; // clear the maximum position, so we start\n            // looking for a new ones\n          }\n          while (pos < nsdf.length - 1 && nsdf[pos] <= 0) {\n            pos++; // loop over all the values below zero\n          }\n        }\n      }\n      if (curMaxPos > 0) {\n        maxPositions.push(curMaxPos);\n      }\n    };\n\n    return function (float32AudioBuffer) {\n\n      // 0. Clear old results.\n      var pitch,\n          maxPositions = [],\n          periodEstimates = [],\n          ampEstimates = [];\n\n      // 1. Calculute the normalized square difference for each Tau value.\n      normalizedSquareDifference(float32AudioBuffer);\n      // 2. Peak picking time: time to pick some peaks.\n      peakPicking();\n\n      var highestAmplitude = -Infinity;\n\n      for (var tau = 0; tau < maxPositions.length; i++) {\n        // make sure every annotation has a probability attached\n        highestAmplitude = Math.max(highestAmplitude, nsdf[tau]);\n\n        if (nsdf[tau] > SMALL_CUTOFF) {\n          // calculates turningPointX and Y\n          parabolicInterpolation(tau);\n          // store the turning points\n          ampEstimates.push(turningPointY);\n          periodEstimates.push(turningPointX);\n          // remember the highest amplitude\n          highestAmplitude = Math.max(highestAmplitude, turningPointY);\n        }\n      }\n\n      if (periodEstimates.length) {\n        // use the overall maximum to calculate a cutoff.\n        // The cutoff value is based on the highest value and a relative\n        // threshold.\n        var actualCutoff = cutoff * highestAmplitude,\n            periodIndex = 0;\n\n        for (var i = 0; i < ampEstimates.length; i++) {\n          if (ampEstimates[i] >= actualCutoff) {\n            periodIndex = i;\n            break;\n          }\n        }\n\n        var period = periodIndex[periodIndex],\n            pitchEstimate = sampleRate / period;\n\n        if (pitchEstimate > LOWER_PITCH_CUTOFF) {\n          pitch = pitchEstimate;\n        } else {\n          pitch = -1;\n        }\n      } else {\n        // no pitch detected.\n        pitch = -1;\n      }\n\n      result.probability = highestAmplitude;\n      result.freq = pitch;\n      return result;\n    };\n  };\n})(PitchFinder);\n\n/*** EXPORTS FROM exports-loader ***/\nmodule.exports = PitchFinder;\n\n/*****************\n ** WEBPACK FOOTER\n ** ./~/exports-loader?PitchFinder!./src/pitchfinder-js/pitchfinder.js\n ** module id = 1\n ** module chunks = 0\n **/\n//# sourceURL=webpack:///./src/pitchfinder-js/pitchfinder.js?./~/exports-loader?PitchFinder')}]);