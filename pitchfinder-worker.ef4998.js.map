{"version":3,"sources":["webpack:///pitchfinder-worker.ef4998.js","webpack:///webpack/bootstrap 0b18ffe2d7c1dc535166","webpack:///./pitchfinder-worker.js","webpack:///./pitchfinder-js/pitchfinder.js"],"names":["modules","__webpack_require__","moduleId","installedModules","exports","module","id","loaded","call","m","c","p","_pitchfinder","detector","self","addEventListener","_ref","data","type","YIN","channelData","pitch","Float32Array","freq","postMessage","config","difference","float32AudioBuffer","index","delta","tau","yinBufferLength","yinBuffer","cumulativeMeanNormalizedDifference","runningSum","absoluteThreshold","threshold","result","probability","foundPitch","parabolicInterpolation","tauEstimate","betterTau","x0","x2","s0","s1","s2","DEFAULT_THRESHOLD","DEFAULT_BUFFER_SIZE","DEFAULT_SAMPLE_RATE","sampleRate","bufferSize","__esModule"],"mappings":"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","file":"pitchfinder-worker.ef4998.js","sourcesContent":["/******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _pitchfinder = __webpack_require__(1);\n\t\n\tvar detector = null; /* eslint-env worker */\n\t\n\t\n\tself.addEventListener('message', function (_ref) {\n\t  var data = _ref.data;\n\t\n\t  switch (data.type) {\n\t    case 'init':\n\t      delete data.type;\n\t      detector = (0, _pitchfinder.YIN)(data);\n\t      return;\n\t\n\t    case 'detect':\n\t      var channelData = data.channelData;\n\t      var pitch = detector(new Float32Array(channelData)).freq;\n\t      postMessage({\n\t        pitch: pitch,\n\t        channelData: channelData\n\t      }, [channelData]);\n\t  }\n\t});\n\n/***/ },\n/* 1 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\texports.__esModule = true;\n\texports.YIN = YIN;\n\t/* An Javascript port of Tarsos's JAVA implementation\n\t * of various pitch detection algorithms, created by\n\t * Joren Six of University College Ghent.\n\t *\n\t * Contains the following algorithms:\n\t * YIN (with and without FFT; the version with requires an external FFT library)\n\t * Average Magnitude Difference\n\t * Dynamic Wavelet\n\t * McLeod Pitch Method\n\t *\n\t * Since this Javascript and we have first-class functions,\n\t * each method creates and returns a pitch detector function\n\t * with the given configuration.  When called with a float32Array\n\t * representing an audio buffer, it returns the pitch.\n\t *\n\t * Methods vary in accuracy and speed.  I have found the best results with YIN.\n\t *\n\t * Find the original project at http://tarsos.0110.be/tag/TarsosDSP\n\t * or on Github at https://github.com/JorenSix/TarsosDSP\n\t */\n\t\n\tfunction YIN(config) {\n\t  var DEFAULT_THRESHOLD = 0.10;\n\t  var DEFAULT_BUFFER_SIZE = 2048;\n\t  var DEFAULT_SAMPLE_RATE = 44100;\n\t  var threshold = config.threshold || DEFAULT_THRESHOLD;\n\t  var sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n\t  var bufferSize = config.bufferSize || DEFAULT_BUFFER_SIZE;\n\t  var yinBuffer = new Float32Array(bufferSize / 2);\n\t  var yinBufferLength = bufferSize / 2;\n\t  var result = {};\n\t\n\t  // Implements the difference function as described in step 2 of the YIN paper.\n\t  function difference(float32AudioBuffer) {\n\t    var index = 0;\n\t    var delta = 0.0;\n\t    var tau = 0;\n\t    for (tau = 0; tau < yinBufferLength; tau++) {\n\t      yinBuffer[tau] = 0;\n\t    }\n\t    for (tau = 1; tau < yinBufferLength; tau++) {\n\t      for (index = 0; index < yinBufferLength; index++) {\n\t        delta = float32AudioBuffer[index] - float32AudioBuffer[index + tau];\n\t        yinBuffer[tau] += delta * delta;\n\t      }\n\t    }\n\t  }\n\t\n\t  // Implements the cumulative mean normalized difference as described in step 3 of the paper.\n\t  function cumulativeMeanNormalizedDifference() {\n\t    yinBuffer[0] = 1;\n\t    yinBuffer[1] = 1;\n\t    var runningSum = 0;\n\t    for (var tau = 1; tau < yinBufferLength; tau++) {\n\t      runningSum += yinBuffer[tau];\n\t      yinBuffer[tau] *= tau / runningSum;\n\t    }\n\t  }\n\t\n\t  function absoluteThreshold() {\n\t    // Since the first two positions in the array are 1,\n\t    // we can start at the third position.\n\t    for (var tau = 2; tau < yinBufferLength; tau++) {\n\t      if (yinBuffer[tau] < threshold) {\n\t        while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n\t          tau++;\n\t        }\n\t        // found tau, exit loop and return\n\t        // store the probability\n\t        // From the YIN paper: The threshold determines the list of\n\t        // candidates admitted to the set, and can be interpreted as the\n\t        // proportion of aperiodic power tolerated\n\t        // within a periodic signal.\n\t        //\n\t        // Since we want the periodicity and and not aperiodicity:\n\t        // periodicity = 1 - aperiodicity\n\t        result.probability = 1 - yinBuffer[tau];\n\t        break;\n\t      }\n\t    }\n\t\n\t    // if no pitch found, set tau to -1\n\t    if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {\n\t      tau = -1;\n\t      result.probability = 0;\n\t      result.foundPitch = false;\n\t    } else {\n\t      result.foundPitch = true;\n\t    }\n\t\n\t    return tau;\n\t  }\n\t\n\t  /**\n\t   * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n\t   * value using parabolic interpolation. This is needed to detect higher\n\t   * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n\t   * for more background\n\t   * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n\t   */\n\t\n\t  function parabolicInterpolation(tauEstimate) {\n\t    var betterTau = void 0;\n\t    var x0 = void 0;\n\t    var x2 = void 0;\n\t\n\t    if (tauEstimate < 1) {\n\t      x0 = tauEstimate;\n\t    } else {\n\t      x0 = tauEstimate - 1;\n\t    }\n\t    if (tauEstimate + 1 < yinBufferLength) {\n\t      x2 = tauEstimate + 1;\n\t    } else {\n\t      x2 = tauEstimate;\n\t    }\n\t    if (x0 === tauEstimate) {\n\t      if (yinBuffer[tauEstimate] <= yinBuffer[x2]) {\n\t        betterTau = tauEstimate;\n\t      } else {\n\t        betterTau = x2;\n\t      }\n\t    } else if (x2 === tauEstimate) {\n\t      if (yinBuffer[tauEstimate] <= yinBuffer[x0]) {\n\t        betterTau = tauEstimate;\n\t      } else {\n\t        betterTau = x0;\n\t      }\n\t    } else {\n\t      var s0 = void 0,\n\t          s1 = void 0,\n\t          s2 = void 0;\n\t      s0 = yinBuffer[x0];\n\t      s1 = yinBuffer[tauEstimate];\n\t      s2 = yinBuffer[x2];\n\t      // fixed AUBIO implementation, thanks to Karl Helgason:\n\t      // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n\t      betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n\t    }\n\t    return betterTau;\n\t  }\n\t\n\t  // Return the pitch of a given signal, or -1 if none is detected.\n\t  return function (float32AudioBuffer) {\n\t    // Step 2\n\t    difference(float32AudioBuffer);\n\t\n\t    // Step 3\n\t    cumulativeMeanNormalizedDifference();\n\t\n\t    // Step 4\n\t    var tauEstimate = absoluteThreshold();\n\t\n\t    // Step 5\n\t    if (tauEstimate !== -1) {\n\t      var betterTau = parabolicInterpolation(tauEstimate);\n\t\n\t      // TODO: optimization!\n\t\n\t      result.freq = sampleRate / betterTau;\n\t    } else {\n\t      result.freq = -1;\n\t    }\n\t\n\t    // Good luck!\n\t    return result;\n\t  };\n\t};\n\n/***/ }\n/******/ ]);\n\n\n/** WEBPACK FOOTER **\n ** pitchfinder-worker.ef4998.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 0b18ffe2d7c1dc535166\n **/","/* eslint-env worker */\nimport {YIN} from './pitchfinder-js/pitchfinder.js';\n\nlet detector = null;\n\nself.addEventListener('message', ({data}) => {\n  switch (data.type) {\n    case 'init':\n      delete data.type;\n      detector = YIN(data);\n      return;\n\n    case 'detect':\n      const channelData = data.channelData;\n      const pitch = detector(new Float32Array(channelData)).freq;\n      postMessage({\n        pitch,\n        channelData: channelData\n      }, [channelData]);\n  }\n});\n\n\n\n/** WEBPACK FOOTER **\n ** ./pitchfinder-worker.js\n **/","/* An Javascript port of Tarsos's JAVA implementation\n * of various pitch detection algorithms, created by\n * Joren Six of University College Ghent.\n *\n * Contains the following algorithms:\n * YIN (with and without FFT; the version with requires an external FFT library)\n * Average Magnitude Difference\n * Dynamic Wavelet\n * McLeod Pitch Method\n *\n * Since this Javascript and we have first-class functions,\n * each method creates and returns a pitch detector function\n * with the given configuration.  When called with a float32Array\n * representing an audio buffer, it returns the pitch.\n *\n * Methods vary in accuracy and speed.  I have found the best results with YIN.\n *\n * Find the original project at http://tarsos.0110.be/tag/TarsosDSP\n * or on Github at https://github.com/JorenSix/TarsosDSP\n */\n\nexport function YIN(config) {\n  const DEFAULT_THRESHOLD = 0.10;\n  const DEFAULT_BUFFER_SIZE = 2048;\n  const DEFAULT_SAMPLE_RATE = 44100;\n  const threshold = config.threshold || DEFAULT_THRESHOLD;\n  const sampleRate = config.sampleRate || DEFAULT_SAMPLE_RATE;\n  const bufferSize = config.bufferSize || DEFAULT_BUFFER_SIZE;\n  const yinBuffer = new Float32Array(bufferSize / 2);\n  const yinBufferLength = bufferSize / 2;\n  const result = {};\n\n  // Implements the difference function as described in step 2 of the YIN paper.\n  function difference(float32AudioBuffer) {\n    let index = 0;\n    let delta = 0.0;\n    let tau = 0;\n    for (tau = 0; tau < yinBufferLength; tau++) {\n      yinBuffer[tau] = 0;\n    }\n    for (tau = 1; tau < yinBufferLength; tau++) {\n      for (index = 0; index < yinBufferLength; index++) {\n        delta = float32AudioBuffer[index] - float32AudioBuffer[index + tau];\n        yinBuffer[tau] += delta * delta;\n      }\n    }\n  }\n\n  // Implements the cumulative mean normalized difference as described in step 3 of the paper.\n  function cumulativeMeanNormalizedDifference() {\n    yinBuffer[0] = 1;\n    yinBuffer[1] = 1;\n    var runningSum = 0;\n    for (var tau = 1; tau < yinBufferLength; tau++) {\n      runningSum += yinBuffer[tau];\n      yinBuffer[tau] *= tau / runningSum;\n    }\n  }\n\n  function absoluteThreshold() {\n    // Since the first two positions in the array are 1,\n    // we can start at the third position.\n    for (var tau = 2; tau < yinBufferLength; tau++) {\n      if (yinBuffer[tau] < threshold) {\n        while (tau + 1 < yinBufferLength && yinBuffer[tau + 1] < yinBuffer[tau]) {\n          tau++;\n        }\n        // found tau, exit loop and return\n        // store the probability\n        // From the YIN paper: The threshold determines the list of\n        // candidates admitted to the set, and can be interpreted as the\n        // proportion of aperiodic power tolerated\n        // within a periodic signal.\n        //\n        // Since we want the periodicity and and not aperiodicity:\n        // periodicity = 1 - aperiodicity\n        result.probability = 1 - yinBuffer[tau];\n        break;\n      }\n    }\n\n    // if no pitch found, set tau to -1\n    if (tau === yinBufferLength || yinBuffer[tau] >= threshold) {\n      tau = -1;\n      result.probability = 0;\n      result.foundPitch = false;\n    } else {\n      result.foundPitch = true;\n    }\n\n    return tau;\n  }\n\n  /**\n   * Implements step 5 of the AUBIO_YIN paper. It refines the estimated tau\n   * value using parabolic interpolation. This is needed to detect higher\n   * frequencies more precisely. See http://fizyka.umk.pl/nrbook/c10-2.pdf and\n   * for more background\n   * http://fedc.wiwi.hu-berlin.de/xplore/tutorials/xegbohtmlnode62.html\n   */\n\n  function parabolicInterpolation(tauEstimate) {\n    let betterTau;\n    let x0;\n    let x2;\n\n    if (tauEstimate < 1) {\n      x0 = tauEstimate;\n    } else {\n      x0 = tauEstimate - 1;\n    }\n    if (tauEstimate + 1 < yinBufferLength) {\n      x2 = tauEstimate + 1;\n    } else {\n      x2 = tauEstimate;\n    }\n    if (x0 === tauEstimate) {\n      if (yinBuffer[tauEstimate] <= yinBuffer[x2]) {\n        betterTau = tauEstimate;\n      } else {\n        betterTau = x2;\n      }\n    } else if (x2 === tauEstimate) {\n      if (yinBuffer[tauEstimate] <= yinBuffer[x0]) {\n        betterTau = tauEstimate;\n      } else {\n        betterTau = x0;\n      }\n    } else {\n      let s0, s1, s2;\n      s0 = yinBuffer[x0];\n      s1 = yinBuffer[tauEstimate];\n      s2 = yinBuffer[x2];\n      // fixed AUBIO implementation, thanks to Karl Helgason:\n      // (2.0f * s1 - s2 - s0) was incorrectly multiplied with -1\n      betterTau = tauEstimate + (s2 - s0) / (2 * (2 * s1 - s2 - s0));\n    }\n    return betterTau;\n  }\n\n  // Return the pitch of a given signal, or -1 if none is detected.\n  return function(float32AudioBuffer) {\n    // Step 2\n    difference(float32AudioBuffer);\n\n    // Step 3\n    cumulativeMeanNormalizedDifference();\n\n    // Step 4\n    const tauEstimate = absoluteThreshold();\n\n    // Step 5\n    if (tauEstimate !== -1) {\n      const betterTau = parabolicInterpolation(tauEstimate);\n\n      // TODO: optimization!\n\n      result.freq = sampleRate / betterTau;\n    } else {\n      result.freq = -1;\n    }\n\n    // Good luck!\n    return result;\n  };\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./pitchfinder-js/pitchfinder.js\n **/"],"sourceRoot":""}